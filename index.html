<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BLE電子秤 重量取得システム</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .connection-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
        }
        .status {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        .connected {
            color: #4CAF50;
        }
        .disconnected {
            color: #f44336;
        }
        .button {
            background-color: #2196F3;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        .button:hover {
            background-color: #1976D2;
        }
        .button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .weight-section {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-top: 30px;
        }
        .weight-area {
            flex: 1;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            padding: 20px;
            text-align: center;
        }
        .weight-area h3 {
            margin-top: 0;
            color: #333;
        }
        .weight-display {
            font-size: 24px;
            font-weight: bold;
            color: #2196F3;
            margin: 15px 0;
            min-height: 30px;
        }
        .get-weight-btn {
            background-color: #4CAF50;
            width: 100%;
        }
        .get-weight-btn:hover {
            background-color: #45a049;
        }
        .error-message {
            color: #f44336;
            font-size: 14px;
            margin-top: 10px;
        }
        .info-message {
            color: #666;
            font-size: 14px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>BLE電子秤 重量取得システム</h1>
        
        <div class="connection-section">
            <div class="status" id="connectionStatus">状態: <span class="disconnected">未接続</span></div>
            <button class="button" id="connectBtn" onclick="connectToScale()">電子秤に接続</button>
            <button class="button" id="disconnectBtn" onclick="disconnectFromScale()" disabled>切断</button>
            <button class="button" id="simulationBtn" onclick="toggleSimulationMode()" style="background-color: #FF9800;">シミュレーション</button>
            <button class="button" id="monitoringBtn" onclick="toggleContinuousMonitoring()" style="background-color: #9C27B0;" disabled>連続監視開始</button>
            <div class="info-message" id="infoMessage">※ HTTPS接続でのみ動作します</div>
        </div>

        <div class="weight-section">
            <div class="weight-area">
                <h3>測定値1</h3>
                <button class="button get-weight-btn" id="getWeight1Btn" onclick="getWeight(1)" disabled>
                    重量取得1
                </button>
                <div class="weight-display" id="weightDisplay1">--.-- g</div>
                <div class="error-message" id="errorMessage1"></div>
            </div>
            
            <div class="weight-area">
                <h3>測定値2</h3>
                <button class="button get-weight-btn" id="getWeight2Btn" onclick="getWeight(2)" disabled>
                    重量取得2
                </button>
                <div class="weight-display" id="weightDisplay2">--.-- g</div>
                <div class="error-message" id="errorMessage2"></div>
            </div>
        </div>
    </div>

<script>
    // グローバル変数
    let bluetoothDevice = null;
    let bluetoothServer = null;
    let service = null;
    let readCharacteristic = null;
    let writeCharacteristic = null;
    let weight1 = null;
    let weight2 = null;
    let continuousMonitoring = false;
    let monitoringInterval = null;
    let receivedDataBuffer = null;
    let dataAccumulator = '';  // 分割データを蓄積するバッファ
    let isWaitingForResponse = false; // データ受信待機中フラグ

    // SDKの仕様に基づく設定値
    const SERVICE_UUID = '5699d362-0c53-11e7-93ae-92361f002671';
    const READ_CHARACTERISTIC_UUID = '5699d646-0c53-11e7-93ae-92361f002671';  // Peripheral→Central
    const WRITE_CHARACTERISTIC_UUID = '5699d772-0c53-11e7-93ae-92361f002671'; // Central→Peripheral
    const DEVICE_NAME_PREFIX = 'A&D_BT_';
    
    // シミュレーションモードの設定
    let simulationMode = false;
    const SIMULATION_WEIGHT_1 = 23.5;
    const SIMULATION_WEIGHT_2 = 154.8;

    // Web Bluetooth API対応チェック
    if (!navigator.bluetooth) {
        document.getElementById('infoMessage').textContent = 'このブラウザはWeb Bluetooth APIに対応していません';
        document.getElementById('connectBtn').disabled = true;
    }

    // 電子秤への接続
    async function connectToScale() {
        try {
            updateInfoMessage('接続中...');
            
            // デバイスの検索・選択
            bluetoothDevice = await navigator.bluetooth.requestDevice({
                filters: [{ namePrefix: DEVICE_NAME_PREFIX }],
                optionalServices: [SERVICE_UUID]
            });

            // GATTサーバーに接続
            bluetoothServer = await bluetoothDevice.gatt.connect();
            
            // サービスの取得
            service = await bluetoothServer.getPrimaryService(SERVICE_UUID);
            
            // キャラクタリスティックの取得
            readCharacteristic = await service.getCharacteristic(READ_CHARACTERISTIC_UUID);
            writeCharacteristic = await service.getCharacteristic(WRITE_CHARACTERISTIC_UUID);
            
            // 通知の設定（データ受信の待機）
            await setupNotification();
            
            // 接続状態の更新
            updateConnectionStatus(true);
            updateInfoMessage('接続成功: ' + bluetoothDevice.name);
            
        } catch (error) {
            console.error('接続エラー:', error);
            updateInfoMessage('接続エラー: ' + error.message);
            updateConnectionStatus(false);
        }
    }

    // 通知の設定
    async function setupNotification() {
        try {
            if (readCharacteristic && readCharacteristic.properties.notify) {
                console.log('通知機能を有効化中...');
                await readCharacteristic.startNotifications();
                
                // データ受信時のイベントハンドラを設定
                readCharacteristic.addEventListener('characteristicvaluechanged', handleNotification);
                console.log('通知機能が有効化されました');
            } else {
                console.log('通知機能は利用できません');
            }
        } catch (error) {
            console.error('通知設定エラー:', error);
        }
    }

    /**
     * 【修正点1】データ受信処理の改善
     *  - 受信したデータをバッファ(dataAccumulator)に蓄積します。
     *  - バッファ内に終端記号(\r\n)が含まれる限りループ処理し、
     *    溜まっている全てのメッセージを処理できるようにしました。
     */
    function handleNotification(event) {
        const value = event.target.value;
        const timestamp = new Date().toISOString();
        const rawData = new Uint8Array(value.buffer);
        const partialString = new TextDecoder().decode(rawData);
        
        console.log(`[${timestamp}] 部分データ受信 (${rawData.length}bytes):`, partialString.replace(/\r\n/g, '\\r\\n'));
        
        // 受信したデータをバッファに蓄積
        dataAccumulator += partialString;
        
        // 終端記号(\r\n)で終わるメッセージを全て処理する
        while (dataAccumulator.includes('\r\n')) {
            const endIndex = dataAccumulator.indexOf('\r\n');
            const completeMessage = dataAccumulator.substring(0, endIndex);
            
            // バッファから処理済みのメッセージを削除
            dataAccumulator = dataAccumulator.substring(endIndex + 2); // `\r\n`の2文字分進める

            console.log(`[${timestamp}] 完全なメッセージを抽出:`, completeMessage);
            
            // 完全なデータをバッファに保存
            receivedDataBuffer = {
                timestamp: timestamp,
                completeMessage: completeMessage,
                rawMessage: completeMessage + '\r\n',
                dataView: new DataView(new TextEncoder().encode(completeMessage).buffer) // \r\nは含めずに渡す
            };
            
            // データ解析を試行
            try {
                const weight = parseWeightData(receivedDataBuffer.dataView);
                console.log(`[${timestamp}] 解析成功: ${weight}g`);

                // UI更新（どのボタンが押されたかにかかわらず、最新の値を表示）
                // 必要であれば、どちらのエリアを更新するか判定するロジックを追加
                document.getElementById('weightDisplay1').textContent = weight.toFixed(2) + ' g';
                clearErrorMessage(1);
            } catch (error) {
                console.log(`[${timestamp}] 解析エラー:`, error.message);
                showErrorMessage(1, `解析エラー: ${error.message}`);
            }
        }
        
        if (dataAccumulator.length > 0) {
            console.log(`[${timestamp}] データ蓄積中... 現在のバッファ: "${dataAccumulator}"`);
        }
    }

    // 電子秤からの切断
    async function disconnectFromScale() {
        try {
            stopContinuousMonitoring();
            dataAccumulator = '';
            
            if (bluetoothDevice && bluetoothDevice.gatt.connected) {
                await bluetoothDevice.gatt.disconnect();
            }
            
            bluetoothDevice = null;
            updateConnectionStatus(false);
            updateInfoMessage('切断しました');
            
        } catch (error) {
            console.error('切断エラー:', error);
            updateInfoMessage('切断エラー: ' + error.message);
        }
    }
    
    // (連続監視の関数は変更なし)
    function toggleContinuousMonitoring() {
        if (continuousMonitoring) {
            stopContinuousMonitoring();
        } else {
            startContinuousMonitoring();
        }
    }

    function startContinuousMonitoring() {
        continuousMonitoring = true;
        const monitoringBtn = document.getElementById('monitoringBtn');
        monitoringBtn.textContent = '連続監視停止';
        monitoringBtn.style.backgroundColor = '#f44336';
        
        monitoringInterval = setInterval(() => {
            const timestamp = new Date().toISOString();
            if (receivedDataBuffer) {
                const timeDiff = Date.now() - new Date(receivedDataBuffer.timestamp).getTime();
                console.log(`[${timestamp}] 最新完全データ (${timeDiff}ms前):`, receivedDataBuffer.rawMessage.replace(/\r\n/g, '\\r\\n'));
            } else {
                console.log(`[${timestamp}] データ待機中...`);
            }
        }, 1000);
        updateInfoMessage('連続監視を開始しました (1秒間隔)');
    }

    function stopContinuousMonitoring() {
        continuousMonitoring = false;
        const monitoringBtn = document.getElementById('monitoringBtn');
        monitoringBtn.textContent = '連続監視開始';
        monitoringBtn.style.backgroundColor = '#9C27B0';
        
        if (monitoringInterval) {
            clearInterval(monitoringInterval);
            monitoringInterval = null;
        }
        if (!simulationMode) {
            updateInfoMessage('連続監視を停止しました');
        }
    }
    
    /**
     * 【修正点2】重量取得処理の変更
     *  - readValue()を直接呼び出すのをやめ、コマンド送信に専念します。
     *  - 実際のデータ受信と解析は、通知イベントで動作する handleNotification 関数に一任します。
     *  - これにより、データが分割されても handleNotification が正しく結合して処理してくれます。
     */
    async function getWeight(areaNumber) {
        try {
            clearErrorMessage(areaNumber);

            if (simulationMode) {
                const weight = areaNumber === 1 ? SIMULATION_WEIGHT_1 : SIMULATION_WEIGHT_2;
                document.getElementById('weightDisplay' + areaNumber).textContent = weight.toFixed(2) + ' g';
                return;
            }

            if (!bluetoothDevice || !bluetoothDevice.gatt.connected || !writeCharacteristic) {
                throw new Error('電子秤との接続が切断されています。再接続してください。');
            }

            console.log(`重量取得コマンド送信 (エリア${areaNumber})...`);

            // "Q\r\n" コマンドを送信して、秤からのデータ送信を要求する
            const command = new TextEncoder().encode('Q\r\n');
            await writeCharacteristic.writeValueWithResponse(command); // または writeValue
            
            console.log('コマンド送信成功。秤からの応答を待機します...');
            updateInfoMessage('データ受信待機中...');
            
            // 実際のデータ表示はhandleNotificationで行われる

        } catch (error) {
            console.error('重量取得コマンド送信エラー:', error);
            if (error.message.includes('disconnected') || error.message.includes('GATT')) {
                updateConnectionStatus(false);
                updateInfoMessage('接続が切断されました。再接続してください。');
            }
            showErrorMessage(areaNumber, 'コマンド送信エラー: ' + error.message);
        }
    }

    /**
     * 【修正点3】データ解析とログ出力の改善
     *  - 解析対象のデータと、そこから抽出したヘッダをコンソールに出力するようにしました。
     *  - trim() を使って、文字列の前後の不要な空白や改行コードを取り除き、解析精度を向上させました。
     */
    function parseWeightData(dataView) {
        try {
            const uint8Array = new Uint8Array(dataView.buffer);
            const responseStr = new TextDecoder().decode(uint8Array).trim();

            // === ご要望のログ出力 ===
            console.log('--- データ解析開始 ---');
            console.log('解析対象の文字列:', `'${responseStr}'`);

            if (responseStr.length < 2) {
                throw new Error('データが短すぎます');
            }
            
            const header = responseStr.substring(0, 2);
            console.log('抽出されたヘッダ:', `'${header}'`);
            // ========================
            
            if (header === 'ST') {
                const parts = responseStr.split(',');
                if (parts.length < 2) {
                    throw new Error('データ形式が不正です (セパレータが見つかりません)');
                }
                const weightData = parts[1].trim(); // " +0000.00 g" のような形式
                const weight = parseFloat(weightData.split(' ')[0]); // 数値部分のみ抽出
                
                console.log('--- データ解析終了 ---');
                return weight;
                
            } else if (header === 'QT') {
                throw new Error('個数モードのデータです（計量モードに切り替えてください）');
            } else if (header === 'US') {
                throw new Error('データが安定していません');
            } else if (header === 'OL') { // "QL"ではなく"OL"(Overload)が一般的
                throw new Error('データが計量範囲を超えています');
            } else {
                throw new Error('未知のヘッダです');
            }
            
        } catch (error) {
            console.error('--- データ解析エラー ---:', error);
            throw error;
        }
    }

    // (以降のヘルパー関数は変更なし)
    function toggleSimulationMode() {
        simulationMode = !simulationMode;
        const simulationBtn = document.getElementById('simulationBtn');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        
        if (simulationMode) {
            simulationBtn.textContent = 'シミュレーション中';
            simulationBtn.style.backgroundColor = '#4CAF50';
            updateConnectionStatus(true);
            updateInfoMessage('シミュレーションモードが有効です');
            connectBtn.disabled = true;
            disconnectBtn.disabled = true;
        } else {
            simulationBtn.textContent = 'シミュレーション';
            simulationBtn.style.backgroundColor = '#FF9800';
            updateConnectionStatus(false);
            updateInfoMessage('シミュレーションモードが無効です');
            connectBtn.disabled = false;
            disconnectBtn.disabled = false;
            clearWeightDisplays();
            stopContinuousMonitoring();
            dataAccumulator = '';
        }
    }

    function clearWeightDisplays() {
        weight1 = null;
        weight2 = null;
        document.getElementById('weightDisplay1').textContent = '--.-- g';
        document.getElementById('weightDisplay2').textContent = '--.-- g';
        clearErrorMessage(1);
        clearErrorMessage(2);
    }

    function updateConnectionStatus(connected) {
        const statusElement = document.getElementById('connectionStatus');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const getWeight1Btn = document.getElementById('getWeight1Btn');
        const getWeight2Btn = document.getElementById('getWeight2Btn');
        const monitoringBtn = document.getElementById('monitoringBtn');
        
        if (connected) {
            const statusText = simulationMode ? 'シミュレーション接続' : '接続済み';
            statusElement.innerHTML = `状態: <span class="connected">${statusText}</span>`;
            connectBtn.disabled = true;
            disconnectBtn.disabled = simulationMode ? true : false;
            getWeight1Btn.disabled = false;
            getWeight2Btn.disabled = false;
            monitoringBtn.disabled = false;
        } else {
            statusElement.innerHTML = '状態: <span class="disconnected">未接続</span>';
            connectBtn.disabled = simulationMode ? true : false;
            disconnectBtn.disabled = true;
            getWeight1Btn.disabled = true;
            getWeight2Btn.disabled = true;
            monitoringBtn.disabled = true;
            stopContinuousMonitoring();
        }
    }

    function updateInfoMessage(message) {
        document.getElementById('infoMessage').textContent = message;
    }

    function showErrorMessage(areaNumber, message) {
        document.getElementById('errorMessage' + areaNumber).textContent = message;
    }

    function clearErrorMessage(areaNumber) {
        document.getElementById('errorMessage' + areaNumber).textContent = '';
    }

    document.addEventListener('DOMContentLoaded', function() {
        updateConnectionStatus(false);
    });
</script>
</body>
</html>

